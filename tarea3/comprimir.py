# buscamos las letras diferentes en la cadena
def obtenerLetras(cadena):
	letras = dict()
	for caracter in cadena:
		if caracter in letras:
			letras[caracter] += 1
		else:
			letras[caracter] = 1
	letras = letras.items()
	return letras


# ordena de mayor a menor por el elemento[x] de la tupla
def ordenarMenorMayor(lista, metodo="listaTuplas"): # lista de tuplas
	if metodo == "listaTuplas":
		return sorted(lista, key=lambda o: o[1])
	else:
		return sorted(lista, key=lambda o: o[0][1])


def crearEnlaces(listaLetras): # recibe una lista de tuplas
	nodos = dict()

	while len(listaLetras) > 1:
		# tomamos los dos nodos menores a unir...
		izq = listaLetras[0]
		der = listaLetras[1]
		# los unimos...
		valorNodo = izq[1] + der[1]
		nodos[izq[0], valorNodo] = 0
		nodos[der[0], valorNodo] = 1
		# creeamos el nuevo nodo...
		listaLetras.append([valorNodo, valorNodo])
		# eliminamos los nodos procesados...
		listaLetras.pop(0)
		listaLetras.pop(0)
		# ordenamos de menor a mayor
		listaLetras = ordenarMenorMayor(listaLetras)
	nodos = nodos.items()	

	return(nodos, listaLetras[0])


def buscarCodigoLetra(nodoActual, nodos, nodoFinal):
	raiz = list()
	while nodoActual != nodoFinal[0]:
		raiz.append(nodoActual[1]) # agregamos el valor de la arista
		nodoActual = nodoActual[0][1] # asignamos el nuevo nodo actual
		# buscamos la tupla del nodoActual
		for items in nodos:
			if items[0][0] == nodoActual:
				nodoActual = items
				break
	raiz.reverse()
	return raiz

def comprimir(cadena, codigos):
	msnComprimido = ""
	for caracter in cadena:
		for nodo, codigo in codigos:
			if nodo == caracter:
				# convertir una cadena de INT en STR
				msnComprimido += "".join(map(str, codigo))
				break
	return msnComprimido

def descomprimir(cadenaBinaria, codigos):
	msnDescomprimido = ""
	posibleLetra = ""
	



	# pendiente




	return msnDescomprimido


def dibujarGrafo(nodos):
	import networkx as nx
	import matplotlib.pyplot as plt

	print "---- DIBUJANDO GRAFO ----"
	print "Si el grafo sale muy amontonado, volver a ejecutar el python"
	print "NOTA: El nodo mayor es la raiz"
	#print "Nodos:\n", nodos

	G = nx.DiGraph() # Se crea un grafo vacio
	R = [tupla[0] for tupla in nodos] # Se crean los nodos
	G.add_edges_from(R) # Se agregan los nodos al grafo vacio
	pos = nx.spring_layout(G) # diseno y posiciones
	# dibujamos todo
	nx.draw_networkx_nodes(G, pos) 
	nx.draw_networkx_edges(G, pos)
	nx.draw_networkx_labels(G, pos)

	for nodosUnion, valorArista in nodos:
		nx.draw_networkx_edge_labels(G, pos, 
			{
				nodosUnion : valorArista
			}
		)

	plt.savefig("Huffman.png"); # guardamos en archivo
	plt.show() # abrimos la ventana
	return	


def main():

	debug = True
	dibujar = False # mostrar el grafo con(networkx) dibujos


	if debug:
		cadena = "aaabbcccccddeeeefhhhhxxh"
	else:
		cadena = '''Huffman code is a lookup table that's generated by a compression scheme known as 
		the Huffman algorithm. While the table itself is only a part of the complete algorithm, it's 
		probably the most challenging component to grasp. It is a binary tree that stores values based on frequency. 
		The more frequent the value, the closer to the root it is located and the smaller its binary representation. 
		Once the lookup table is created, it is used to compress the data, and subsequently to decompress it.'''
	
	print "cadena:", cadena

	# filtro para quitar tabulaciones y saltos de linea
	cadena = cadena.replace("\t", "").replace("\n", " ") 

	letras = obtenerLetras(cadena)
	# ordenar las letras unicas por frecuencias menor-mayor	
	letrasOrdenadas = ordenarMenorMayor(letras)
	# buscamos los enlaces de los nodos
	(nodos, nodoFinal) = crearEnlaces(letrasOrdenadas)
	# ordenar los nodos de menor a mayor
	nodos = ordenarMenorMayor(nodos, "nodos")

	copyNodos = list(nodos) 
	# buscamos los codigos(el valor de la aristas) de cada nodo
	codigos = list()
	while len(copyNodos) > 0:
		nodoActual = copyNodos[0] # tomamos el primer elemento de los copyNodos
		codigos.append([nodoActual[0][0], buscarCodigoLetra(nodoActual, copyNodos, nodoFinal)]) # buscamos su raiz
		copyNodos.pop(0) # eliminamos el nodo procesado	


	# pasar la cadena original en binaria(comprimir)
	msnComprimido = comprimir(cadena, codigos)
	# rescatar la cadena original a partir de la binaria(descomprimir)
	msnDescomprimido = descomprimir(msnComprimido, cadena)

	print "-----"
	print "Total de caracteres en la cadena:", len(cadena)
	print "Total de caracteres unicos:", len(letras)
	print "Codigos:\n", codigos
	print "-----"
	print "Mensaje comprimido:\n", msnComprimido
	print "Mensaje descomprimido:\n", msnDescomprimido

	if dibujar:
		# dibujamos el grafo
		dibujarGrafo(nodos)


main()